DECLARE PLUGIN "coq-waterproof.plugin"

{

open Ltac_plugin
open Ltac_plugin.G_auto
open Pp

open Exceptions
open Hint_dataset
open Proofutils
open Wauto
open Weauto

}

{
let eval_uconstrs ist cs =
  let flags = Pretyping.{
    use_coercions = true;
    use_typeclasses = NoUseTC;
    solve_unification_constraints = true;
    fail_evar = false;
    expand_evars = true;
    program_mode = false;
    polymorphic = false;
  } in
  let map c env sigma = c env sigma in
  List.map (fun c -> map (Tacinterp.type_uconstr ~flags ist c)) cs
}

(**
  Waterproof auto tactic

  Partial rewrite of the [[auto]] tactic in [`coq-plugin.Ltac_plugin.G_auto`]

  Its use is the same as `auto [using ...]`
*)
TACTIC EXTEND wauto
  | [ "wauto" auto_using(lems) ] ->
    {
      let trace = new_trace Off in
      wauto trace 5 (eval_uconstrs ist lems) (positive_databases ())
    }
END

(**
  Waterproof info_auto tactic

  Equivalent of [info_auto] with [wauto]
*)
TACTIC EXTEND info_wauto
  | [ "info_wauto" auto_using(lems) ] ->
    {
      let trace = new_trace Info in
      let tactic = wauto trace 5 (eval_uconstrs ist lems) (positive_databases ()) in
      let print = lazy (
        Proofview.tclUNIT (
          let applied = Backtracking.keep_applied !(trace.trace) in
          Feedback.msg_notice (str "Applied hints :" ++ (List.fold_left (fun acc (depth, hint, src) -> acc ++ str "\n" ++ Pp.int depth ++ str " " ++ hint ++ str "(" ++ src ++ str ")") (str "") applied));
        )
      ) in
      tclRealThen tactic print
    }
END

(**
  Waterproof trace auto tactic

  Equivalent of `trace auto` with [wauto]
*)
TACTIC EXTEND debug_wauto
  | [ "debug_wauto" auto_using(lems) ] ->
    {
      let trace = new_trace Debug in
      wauto trace 5 (eval_uconstrs ist lems) (positive_databases ())
    }
END

(**
  Waterproof eauto tactic

  Rewrite of the [[eauto]] tactic in [`coq-plugin.Ltac_plugin.G_auto`]

  Its use is the same as `eauto [using ...]`
*)
TACTIC EXTEND weauto
  | [ "weauto" auto_using(lems) ] ->
    {
      let trace = new_trace Off in
      weauto trace 5 (eval_uconstrs ist lems) (positive_databases ())
    }
END

(**
  Waterproof info_auto tactic

  Equivalent of [info_auto] with [wauto]
*)
TACTIC EXTEND info_weauto
  | [ "info_weauto" auto_using(lems) ] ->
    {
      let trace = new_trace Info in
      weauto trace 5 (eval_uconstrs ist lems) (positive_databases ())
    }
END

(**
  Waterproof trace auto tactic

  Equivalent of `trace auto` with [wauto]
*)
TACTIC EXTEND debug_weauto
  | [ "debug_weauto" auto_using(lems) ] ->
    {
      let trace = new_trace Debug in
      weauto trace 5 (eval_uconstrs ist lems) (positive_databases ())
    }
END

(**
  Restricted waterproof auto tactic

  Its use is the same as the [wauto] tacitc but it will fail if one of the given lemmas is not used
*)
TACTIC EXTEND rwauto
  | [ "rwauto" auto_using(lems) ] ->
    {
      let lemma_names =
        let env = Global.env () in
        let sigma = Evd.from_env env in
        List.map (Printer.pr_closed_glob_env env sigma) lems in
      let trace = new_trace Off in
      let tactic = wauto trace 5 (eval_uconstrs ist lems) (positive_databases ()) in
      let print = lazy (
        let used_lemmas = ref StringMap.empty in
        List.iter (fun name -> used_lemmas := StringMap.add (string_of_ppcmds name) false !used_lemmas) lemma_names;
        Proofview.tclUNIT (
          let applied_lemmas = Backtracking.keep_applied !(trace.trace) in
          List.iter (fun (_, hint, _) ->
            used_lemmas := StringMap.update (string_of_ppcmds hint) (fun value ->
              match value with
                | None -> None
                | Some _ -> Some true
            ) !used_lemmas
          ) applied_lemmas;
          let unused_lemmas = ref [] in
          if (StringMap.exists (fun name is_used -> if not is_used then (unused_lemmas := name::!unused_lemmas); not is_used) !used_lemmas) then throw (UnusedLemma !unused_lemmas);
        )
      ) in
      tclRealThen tactic print
    }
END