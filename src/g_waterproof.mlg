DECLARE PLUGIN "coq-waterproof.plugin"

{
  
open Ltac_plugin
open Ltac_plugin.G_auto
open Proofview

open Hint_dataset
open Hint_dataset_declarations
open Wauto
open Waterprove
open Weauto

}

{
let eval_uconstrs ist cs =
  let flags = Pretyping.{
    use_coercions = true;
    use_typeclasses = NoUseTC;
    solve_unification_constraints = true;
    fail_evar = false;
    expand_evars = true;
    program_mode = false;
    polymorphic = false;
  } in
  let map c env sigma = c env sigma in
  List.map (fun c -> map (Tacinterp.type_uconstr ~flags ist c)) cs
}

(**
  Waterproof [auto] tactic

  Partial rewrite of the [[auto]] tactic in [`coq-plugin.Ltac_plugin.G_auto`]

  Its use is the same as `auto [using ...]`
*)
TACTIC EXTEND wauto
  | [ "wauto" auto_using(lems) ] ->
    {
      tclIGNORE @@ wauto false 5 (eval_uconstrs ist lems) (get_current_databases Positive)
    }
END

(**
  Waterproof [info_auto] tactic

  Equivalent of [info_auto] with {! wauto}
*)
TACTIC EXTEND info_wauto
  | [ "info_wauto" auto_using(lems) ] ->
    {
      tclIGNORE @@ wauto true 5 (eval_uconstrs ist lems) (get_current_databases Positive)
    }
END

(**
  Waterproof [eauto] tactic

  Rewrite of the [eauto] tactic in [`coq-plugin.Ltac_plugin.G_auto`]

  Its use is the same as [eauto <using ...> <with ...>]
*)
TACTIC EXTEND weauto
  | [ "weauto" auto_using(lems) hintbases(db) ] ->
    {
      tclIGNORE (weauto false 5 (eval_uconstrs ist lems) (match db with 
        | None -> (get_current_databases Positive)
        | Some db -> db
      ))
    }
END

(**
  Waterproof [info_eauto] tactic

  Equivalent of [info_auto] with {! weauto}
*)
TACTIC EXTEND info_weauto
  | [ "info_weauto" auto_using(lems) hintbases(db) ] ->
    {
      tclIGNORE (weauto true 5 (eval_uconstrs ist lems) (match db with 
        | None -> (get_current_databases Positive)
        | Some db -> db
      ))
    }
END

(**
  Restricted waterproof auto tactic

  Its use is the same as the {! wauto} tacitc but it will fail if one of the given lemmas is not used
*)
TACTIC EXTEND rwauto
  | [ "rwauto" auto_using(lems) ] ->
    {
      let lemma_names =
        let env = Global.env () in
        let sigma = Evd.from_env env in
        List.map (Printer.pr_closed_glob_env env sigma) lems in
      tclIGNORE @@ rwauto false 5 (eval_uconstrs ist lems) (get_current_databases Positive) lemma_names []
    }
END

(**
  Restricted Waterproof [info_auto] tactic

  Equivalent of [info_auto] with {! rwauto}
*)
  TACTIC EXTEND info_rwauto
  | [ "info_rwauto" auto_using(lems) ] ->
    {
      let lemma_names =
        let env = Global.env () in
        let sigma = Evd.from_env env in
        List.map (Printer.pr_closed_glob_env env sigma) lems in
      tclIGNORE @@ rwauto true 5 (eval_uconstrs ist lems) (get_current_databases Positive) lemma_names []
    }
END

(**
  Restricted waterproof auto tactic

  Its use is the same as the {! waeuto} tacitc but it will fail if one of the given lemmas is not used
*)
  TACTIC EXTEND rweauto
  | [ "rweauto" auto_using(lems) ] ->
    {
      let lemma_names =
        let env = Global.env () in
        let sigma = Evd.from_env env in
        List.map (Printer.pr_closed_glob_env env sigma) lems in
      tclIGNORE @@ rweauto false 5 (eval_uconstrs ist lems) (get_current_databases Positive) lemma_names []
    }
END

(**
  Restricted Waterproof [info_eauto] tactic

  Equivalent of [info_eauto] with {! rweauto}
*)
  TACTIC EXTEND info_rweauto
  | [ "info_rweauto" auto_using(lems) ] ->
    {
      let lemma_names =
        let env = Global.env () in
        let sigma = Evd.from_env env in
        List.map (Printer.pr_closed_glob_env env sigma) lems in
      tclIGNORE @@ rweauto true 5 (eval_uconstrs ist lems) (get_current_databases Positive) lemma_names []
    }
END

(**
  Test tactic used to check if the solve of the current goal by [waterprove] is shielded
*)
TACTIC EXTEND shield
  | [ "shield" ] ->
    {
      shield_test ()
    }
END

(**
  Waterprove tactic

  Main automation tactic of the coq-waterproof library
*)
TACTIC EXTEND waterprove
  | [ "waterprove" auto_using(lems) ] ->
    {
      waterprove 5 ?shield:(Some true) (eval_uconstrs ist lems) Positive
    }
END