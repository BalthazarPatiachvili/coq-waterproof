DECLARE PLUGIN "coq-waterproof.plugin"

{

open Ltac_plugin
open Ltac_plugin.G_auto
open Pp

open Hint_dataset
open Wauto

}

(**
  Waterproof auto tactic

  Partial rewrite of the [`auto`] tactic in [`coq-plugin.Ltac_plugin.G_auto`]

  Its use is the same as `auto [using ...]`
*)
TACTIC EXTEND wauto
  | [ "wauto" auto_using(lems) ] ->
    {
      let debug = new_debug Off in
      wauto debug 5 (eval_uconstrs ist lems) (positive_databases ())
    }
END

(**
  Waterproof info_auto tactic

  Equivalent of `info_auto` with `wauto`
*)
TACTIC EXTEND info_wauto
  | [ "info_wauto" auto_using(lems) ] ->
    {
      let debug = new_debug Info in
      let tactic = wauto debug 5 (eval_uconstrs ist lems) (positive_databases ()) in
      let print = lazy (
        let (_, _, trace, _) = debug in
        Proofview.tclUNIT (
          let applied = Backtracking.keep_applied !trace in
          Feedback.msg_notice (str "Applied hints :" ++ (List.fold_left (fun acc (depth, hint, src) -> acc ++ str "\n" ++ Pp.int depth ++ str " " ++ hint ++ str "(" ++ src ++ str ")") (str "") applied));
        )
      ) in
      Proofutils.tclRealThen tactic print
    }
END

(**
  Restricted waterproof auto tactic

  Its use is the same as the `wauto` tacitc but it will fail if one of the given lemmas is not used
*)
TACTIC EXTEND rwauto
  | [ "rwauto" auto_using(lems) ] ->
    {
      let debug = new_debug Info in
      let tactic = wauto debug 5 (eval_uconstrs ist lems) (positive_databases ()) in
      let print = lazy (
        let (_, _, trace, lemma_names) = debug in
        Proofview.tclUNIT (
          List.iter Feedback.msg_notice !lemma_names
        )
      ) in
      Proofutils.tclRealThen tactic print
    }
END